# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/dagu-org/dagu/main/schemas/dag.schema.json
#   timestamp: 2025-06-18T12:29:30+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from homelab_pydantic import HomelabBaseModel
from pydantic import ConfigDict, Field


class Type(str, Enum):
    graph = "graph"
    chain = "chain"
    agent = "agent"


class Smtp(HomelabBaseModel):
    host: str | None = Field(None, description="SMTP server hostname")
    port: str | int | None = Field(None, description="SMTP server port")
    username: str | None = Field(None, description="SMTP authentication username")
    password: str | None = Field(None, description="SMTP authentication password")


class MailOn(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Send email notification when DAG fails"
    )
    success: bool | None = Field(
        None, description="Send email notification when DAG succeeds"
    )


class Type1(str, Enum):
    docker = "docker"
    http = "http"
    mail = "mail"
    ssh = "ssh"
    jq = "jq"


class Executor(HomelabBaseModel):
    type: Type1 = Field(..., description="Type of executor to use for this step")
    config: dict[str, Any] | None = Field(
        None, description="Executor-specific configuration options"
    )


class ContinueOn(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Continue dag-run even if this step fails"
    )
    skipped: bool | None = Field(
        None,
        description="Continue dag-run even if this step is skipped due to preconditions",
    )
    exit_code: int | list[int] | None = Field(None, alias="exitCode")
    output: str | list[str] | None = None
    mark_success: bool | None = Field(
        None,
        alias="markSuccess",
        description="Mark the step as successful even if it technically failed but met continue conditions",
    )


class RetryPolicy(HomelabBaseModel):
    limit: int | str | None = Field(
        None, description="Maximum number of retry attempts"
    )
    interval_sec: int | str | None = Field(
        None, alias="intervalSec", description="Seconds to wait between retry attempts"
    )
    exit_code: list[int] | None = Field(
        None,
        alias="exitCode",
        description="List of exit codes that should trigger a retry. If not specified, all non-zero exit codes will trigger a retry.",
    )


class RepeatPolicy(HomelabBaseModel):
    repeat: bool | None = Field(None, description="Whether to repeat this step")
    interval_sec: int | None = Field(
        None, alias="intervalSec", description="Interval in seconds between repetitions"
    )
    limit: int | None = Field(
        None,
        description="Maximum number of times this step will be executed. Once reached, the step stops repeating regardless of other conditions.",
        ge=1,
    )
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate for repeat-until. Can include shell commands, environment variables, or command substitutions.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix.",
    )
    exit_code: int | list[int] | None = Field(
        None,
        alias="exitCode",
        description="Exit code or list of exit codes that will stop repetition. If not specified, all non-zero exit codes will trigger repetition.",
    )


class Parallel(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    items: str | list[str | float | dict[str, Any]]
    max_concurrent: int | None = Field(
        8,
        alias="maxConcurrent",
        description="Maximum number of concurrent executions (default: 8, maximum: 1000)",
        ge=1,
        le=1000,
    )


class Condition(HomelabBaseModel):
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate. Can include shell commands, environment variables, or command substitutions with backticks.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix (e.g., 're:0[1-9]' for matching numbers 01-09).",
    )


class MailConfig(HomelabBaseModel):
    from_: str | None = Field(
        None,
        alias="from",
        description="Email address to use as the sender address for notifications.",
    )
    to: str | None = Field(
        None,
        description="Email address(es) to receive notifications. Multiple addresses should be comma-separated.",
    )
    prefix: str | None = Field(
        None,
        description="Text to prepend to the email subject line. Useful for filtering or categorizing notification emails.",
    )
    attach_logs: bool | None = Field(
        None,
        alias="attachLogs",
        description="When true, relevant log files will be attached to the notification email.",
    )


class Step(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(
        ...,
        description="Unique identifier for the step within this DAG. Required field.",
    )
    id: str | None = Field(
        None,
        description="Optional short identifier for the step. Can be used in variable references like ${id.stdout} to access step properties. Must be unique within the DAG if specified.",
    )
    description: str | None = Field(
        None,
        description="Brief description of what this step does. Helps document the step's purpose.",
    )
    dir: str | None = Field(
        None,
        description="Working directory in which this step's command or script will be executed.",
    )
    executor: str | Executor | None = Field(
        None,
        description="Specialized executor configuration for running the step (e.g., docker for containerized execution, http for API calls, mail for sending emails).",
    )
    command: str | list[str] | None = Field(
        None,
        description="Command to execute. Can be a shell command, script interpreter, or executable. If omitted when script is provided, uses system default shell.",
    )
    shell: str | None = Field(
        None,
        description="Specific shell to use for executing the command. Defaults to $SHELL or sh if not specified.",
    )
    shell_packages: list[str] | None = Field(
        None,
        alias="shellPackages",
        description="List of packages to install before executing the step. Useful for ensuring dependencies are available. It's only available when the shell is nix-shell.",
    )
    script: str | None = Field(
        None,
        description="Multi-line script content that will be executed. Gets piped into the command if specified, otherwise uses default shell.",
    )
    stdout: str | None = Field(
        None,
        description="File path where the step's standard output (stdout) will be written.",
    )
    stderr: str | None = Field(
        None,
        description="File path where the step's standard error (stderr) will be written.",
    )
    output: str | None = Field(
        None,
        description="Variable name to capture the command's stdout. This output can be referenced in subsequent steps.",
    )
    depends: str | list[str] | None = None
    continue_on: ContinueOn | None = Field(
        None,
        alias="continueOn",
        description="Conditions under which the DAG should continue executing even if this step fails or is skipped.",
    )
    retry_policy: RetryPolicy | None = Field(
        None,
        alias="retryPolicy",
        description="Configuration for automatically retrying failed steps.",
    )
    repeat_policy: RepeatPolicy | None = Field(
        None,
        alias="repeatPolicy",
        description="Configuration for repeatedly executing this step at fixed intervals or until a condition is met. Supports string matching, command substitution, and exit code checks.",
    )
    mail_on_error: bool | None = Field(
        None,
        alias="mailOnError",
        description="Send an email notification if this specific step fails.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be met before this step can run. Supports command exit codes, environment variables, and regex matching.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    signal_on_stop: str | None = Field(
        None,
        alias="signalOnStop",
        description="Signal to send when stopping this step (e.g., SIGINT). If empty, uses same signal as parent process.",
    )
    run: str | None = Field(None, description="Name of a DAG to run.")
    params: str | None = Field(None, description="Parameters to pass to the DAG.")
    parallel: str | list[str | float | dict[str, Any]] | Parallel | None = Field(
        None,
        description="Configuration for parallel execution of child DAGs. Only applicable when 'run' is specified. Allows processing multiple items concurrently using the same workflow definition.",
    )


class HandlerOn(HomelabBaseModel):
    failure: Step | None = None
    success: Step | None = None
    cancel: Step | None = None
    exit: Step | None = None


class Model(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Name of the DAG. If omitted, defaults to the YAML filename without extension.",
    )
    description: str | None = Field(
        None,
        description="A brief description explaining what this DAG does. This helps document the DAG's purpose.",
    )
    group: str | None = Field(
        None,
        description="An organizational label used to group related DAGs together. Useful for categorizing DAGs in the UI, e.g., 'DailyJobs', 'Analytics'.",
    )
    dotenv: str | list[str] | None = Field(
        None,
        description="Specifies candidate .env files to load environment variables from. By default, no env files are loaded unless explicitly specified.",
    )
    schedule: str | None = Field(
        None,
        description="Cron expression that determines how often the DAG triggers (e.g., '5 4 * * *' runs daily at 04:05). If omitted, the DAG will only run manually.",
    )
    skip_if_successful: bool | None = Field(
        None,
        alias="skipIfSuccessful",
        description="When true, Dagu checks if this DAG has already succeeded since the last scheduled time. If it has, Dagu will skip the current scheduled run. This is useful for resource-intensive tasks or data processing jobs that shouldn't run twice. Note: Manual triggers always run regardless of this setting.",
    )
    tags: str | list[str] | None = Field(
        None,
        description="Tags for categorizing and searching DAGs. Useful for filtering and organizing DAGs.",
    )
    type: Type | None = Field(
        Type.chain,
        description="Execution type for steps. 'chain' (default) executes steps sequentially in the order they are defined, with each step automatically depending on the previous one. 'graph' uses dependency-based execution where steps run based on their 'depends' field. 'agent' is reserved for future agent-based execution.",
    )
    env: list[dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Environment variables available to all steps in the DAG. Can use shell expansions, references to other environment variables, or command substitutions. Note: These won't be stored in execution history data for security.",
    )
    log_dir: str | None = Field(
        None,
        alias="logDir",
        description="Base directory for storing logs. Defaults to ${HOME}/.local/share/logs if not specified.",
    )
    handler_on: HandlerOn | None = Field(
        None,
        alias="handlerOn",
        description="Lifecycle event hooks that define commands to execute when the DAG succeeds, fails, is cancelled, or exits. Useful for cleanup, notifications, or triggering dependent DAGs.",
    )
    smtp: Smtp | None = Field(
        None, description="SMTP server configuration for sending email notifications."
    )
    mail_on: MailOn | None = Field(
        None,
        alias="mailOn",
        description="Configuration for sending email notifications on DAG success or failure.",
    )
    error_mail: MailConfig | None = Field(
        None,
        alias="errorMail",
        description="Email configuration specifically for error notifications.",
    )
    info_mail: MailConfig | None = Field(
        None,
        alias="infoMail",
        description="Email configuration for informational notifications.",
    )
    timeout_sec: int | None = Field(
        None,
        alias="timeoutSec",
        description="Maximum number of seconds allowed for the entire DAG to finish. If exceeded, the DAG is considered timed out.",
    )
    delay_sec: int | None = Field(
        None,
        alias="delaySec",
        description="Delay in seconds before starting the first node. Useful for staggering workloads.",
    )
    restart_wait_sec: int | None = Field(
        None,
        alias="restartWaitSec",
        description="Number of seconds to wait before restarting a failed or stopped DAG. Typically used with a process supervisor.",
    )
    hist_retention_days: int | None = Field(
        None,
        alias="histRetentionDays",
        description="Number of days to retain execution history. After this period, older run logs/history can be purged.",
    )
    max_active_runs: int | None = Field(
        1,
        alias="maxActiveRuns",
        description="Maximum number of concurrent DAG runs allowed. Useful for limiting resource usage and preventing overload. If exceeded, new runs will be queued until existing ones complete. Defaults to 1. Set to -1 to disable queueing for this DAG.",
    )
    queue: str | None = Field(
        None,
        description="Name of the queue to assign this DAG to. If not specified, defaults to the DAG name. Used with global queue configuration to control concurrent execution across multiple DAGs.",
    )
    max_active_steps: int | None = Field(
        None,
        alias="maxActiveSteps",
        description="Maximum number of concurrent steps that can be active at once. Useful for limiting resource usage.",
    )
    max_clean_up_time_sec: int | None = Field(
        None,
        alias="maxCleanUpTimeSec",
        description="Maximum time in seconds to spend cleaning up (stopping steps, finalizing logs) before forcing shutdown. If exceeded, processes will be killed.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be satisfied before the DAG can run. Can use shell expansions or command substitutions to validate external states.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    params: str | list[dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Default parameters that can be overridden when triggering the DAG. Can be positional (accessed as $1, $2) or named (accessed as ${KEY}).",
    )
    steps: list[Step] | dict[str, Step] | None = None
