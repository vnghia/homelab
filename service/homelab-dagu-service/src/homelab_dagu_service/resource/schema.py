# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/dagu-org/dagu/main/schemas/dag.schema.json
#   timestamp: 2025-10-04T19:34:43+00:00

from __future__ import annotations

from enum import Enum
from typing import Any

from homelab_pydantic import HomelabBaseModel, HomelabRootModel
from pydantic import ConfigDict, Field


class Schedule(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    start: str | list[str] | None = None
    stop: str | list[str] | None = None
    restart: str | list[str] | None = None


class Type(str, Enum):
    graph = "graph"
    chain = "chain"
    agent = "agent"


class Smtp(HomelabBaseModel):
    host: str | None = Field(None, description="SMTP server hostname")
    port: str | int | None = Field(None, description="SMTP server port")
    username: str | None = Field(None, description="SMTP authentication username")
    password: str | None = Field(None, description="SMTP authentication password")


class MailOn(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Send email notification when DAG fails"
    )
    success: bool | None = Field(
        None, description="Send email notification when DAG succeeds"
    )


class Params(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    schema_: str = Field(
        ...,
        alias="schema",
        description="Path to JSON Schema file (local file or remote URL) for parameter validation",
    )
    values: dict[str, Any] | None = Field(
        None, description="Default parameter values to be validated against the schema"
    )


class RunConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    disable_param_edit: bool | None = Field(
        False,
        alias="disableParamEdit",
        description="When true, prevents users from modifying DAG parameters when starting the DAG. Defaults to false (users can edit parameters).",
    )
    disable_run_id_edit: bool | None = Field(
        False,
        alias="disableRunIdEdit",
        description="When true, prevents users from entering custom run IDs when starting the DAG. Defaults to false (users can enter custom run IDs).",
    )


class Type1(str, Enum):
    docker = "docker"
    http = "http"
    mail = "mail"
    ssh = "ssh"
    jq = "jq"


class Executor(HomelabBaseModel):
    type: Type1 = Field(..., description="Type of executor to use for this step")
    config: dict[str, Any] | None = Field(
        None,
        description="Executor-specific configuration options. For the Docker executor, set `image`, `containerName`, or both; with only `containerName` the container must already be running, and with both set Dagu creates the container from the `image` if it is missing or stopped.",
    )


class ContinueOn(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Continue dag-run even if this step fails"
    )
    skipped: bool | None = Field(
        None,
        description="Continue dag-run even if this step is skipped due to preconditions",
    )
    exit_code: int | list[int] | None = Field(None, alias="exitCode")
    output: str | list[str] | None = None
    mark_success: bool | None = Field(
        None,
        alias="markSuccess",
        description="Mark the step as successful even if it technically failed but met continue conditions",
    )


class RetryPolicy(HomelabBaseModel):
    limit: int | str | None = Field(
        None, description="Maximum number of retry attempts"
    )
    interval_sec: int | str | None = Field(
        None, alias="intervalSec", description="Seconds to wait between retry attempts"
    )
    backoff: bool | float | None = Field(
        None, description="Exponential backoff multiplier for retry delays"
    )
    max_interval_sec: int | None = Field(
        None,
        alias="maxIntervalSec",
        description="Maximum interval in seconds (caps exponential growth)",
    )
    exit_code: list[int] | None = Field(
        None,
        alias="exitCode",
        description="List of exit codes that should trigger a retry. If not specified, all non-zero exit codes will trigger a retry.",
    )


class Repeat(str, Enum):
    while_ = "while"
    until = "until"


class RepeatPolicy(HomelabBaseModel):
    repeat: bool | Repeat | None = Field(
        None,
        description="Determines if and how the step should be repeated. Can be a boolean or a string ('while' or 'until').",
    )
    interval_sec: int | None = Field(
        None, alias="intervalSec", description="Interval in seconds between repetitions"
    )
    limit: int | None = Field(
        None,
        description="Maximum number of times this step will be executed. Once reached, the step stops repeating regardless of other conditions.",
        ge=1,
    )
    backoff: bool | float | None = Field(
        None, description="Exponential backoff multiplier for repeat delays"
    )
    max_interval_sec: int | None = Field(
        None,
        alias="maxIntervalSec",
        description="Maximum interval in seconds (caps exponential growth)",
    )
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate for repeat-until. Can include shell commands, environment variables, or command substitutions.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix.",
    )
    exit_code: int | list[int] | None = Field(
        None,
        alias="exitCode",
        description="Exit code or list of exit codes that will stop repetition. If not specified, all non-zero exit codes will trigger repetition.",
    )


class Parallel(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    items: str | list[str | float | dict[str, Any]]
    max_concurrent: int | None = Field(
        8,
        alias="maxConcurrent",
        description="Maximum number of concurrent executions (default: 8, maximum: 1000)",
        ge=1,
        le=1000,
    )


class Condition(HomelabBaseModel):
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate. Can include shell commands, environment variables, or command substitutions with backticks.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix (e.g., 're:0[1-9]' for matching numbers 01-09).",
    )


class MailConfig(HomelabBaseModel):
    from_: str | None = Field(
        None,
        alias="from",
        description="Email address to use as the sender address for notifications.",
    )
    to: str | list[str] | None = Field(
        None,
        description="Email address(es) to receive notifications. Can be a single string or an array of strings.",
    )
    prefix: str | None = Field(
        None,
        description="Text to prepend to the email subject line. Useful for filtering or categorizing notification emails.",
    )
    attach_logs: bool | None = Field(
        None,
        alias="attachLogs",
        description="When true, relevant log files will be attached to the notification email.",
    )


class Resource(HomelabBaseModel):
    service_name: str | None = Field(
        None,
        alias="service.name",
        description="Service name for the traces. Defaults to 'dagu' if not specified. Can use variables like ${DAG_NAME}.",
    )
    service_version: str | None = Field(
        None,
        alias="service.version",
        description="Version of the service producing the traces.",
    )
    deployment_environment: str | None = Field(
        None,
        alias="deployment.environment",
        description="Deployment environment (e.g., production, staging, development).",
    )


class OtelConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    enabled: bool | None = Field(
        None,
        description="Enable or disable OpenTelemetry tracing for this DAG. When false, no traces will be exported.",
    )
    endpoint: str | None = Field(
        None,
        description="OTLP endpoint URL for exporting traces. Supports both gRPC (e.g., http://localhost:4317) and HTTP (e.g., http://localhost:4318/v1/traces) protocols.",
    )
    headers: dict[str, str] | None = Field(
        None,
        description="Custom headers to include with OTLP export requests. Useful for authentication (e.g., Authorization: Bearer token).",
    )
    insecure: bool | None = Field(
        False,
        description="Skip TLS certificate verification when connecting to the OTLP endpoint. Only use in development environments.",
    )
    timeout: str | None = Field(
        None,
        description="Timeout for exporting traces to the OTLP endpoint. Accepts duration strings like '30s', '1m', '5m'.",
    )
    resource: Resource | None = Field(
        None,
        description="Resource attributes to attach to all spans. Common attributes include service.name, service.version, and deployment.environment.",
    )


class PullPolicy(str, Enum):
    always = "always"
    never = "never"
    missing = "missing"


class Startup(str, Enum):
    keepalive = "keepalive"
    entrypoint = "entrypoint"
    command = "command"


class WaitFor(str, Enum):
    running = "running"
    healthy = "healthy"


class Container(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    image: str = Field(
        ...,
        description="Container image to use (e.g., 'python:3.11', 'node:20'). Required when using container configuration.",
    )
    pull_policy: PullPolicy | None = Field(
        PullPolicy.missing,
        alias="pullPolicy",
        description="Image pull policy. 'always' pulls the image every time, 'never' uses only local images, 'missing' pulls only if not present locally.",
    )
    env: list[str] | None = Field(
        None,
        description="Environment variables to set in the container. Format: 'KEY=value'. Supports variable expansion (e.g., 'API_KEY=${API_KEY}').",
    )
    volumes: list[str] | None = Field(
        None,
        description="Volume mounts for the container. Format: 'host_path:container_path[:mode]' where mode is 'ro' for read-only or 'rw' (default) for read-write. Relative paths (starting with './' or '.') are resolved relative to the DAG's workingDir.",
    )
    user: str | None = Field(
        None,
        description="User (and optionally group) to run the container as. Format: 'user' or 'user:group' (e.g., '1000' or '1000:1000').",
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory inside the container. Commands will be executed from this directory.",
    )
    platform: str | None = Field(
        None,
        description="Platform for the container (e.g., 'linux/amd64', 'linux/arm64'). Useful for ensuring compatibility on different architectures.",
    )
    ports: list[str] | None = Field(
        None,
        description="Ports to expose from the container. Format: 'host_port:container_port' or just 'container_port'.",
    )
    network: str | None = Field(
        None,
        description="Network mode for the container (e.g., 'host', 'bridge', 'none', or a custom network name).",
    )
    startup: Startup | None = Field(
        Startup.keepalive,
        description="Startup mode for the DAG-level container: 'keepalive' uses an internal keepalive/sleep, 'entrypoint' honors the image's ENTRYPOINT/CMD, 'command' runs the provided command array.",
    )
    command: list[str] | None = Field(
        None,
        description="Command to execute when startup is 'command'. Must be a non-empty array.",
    )
    wait_for: WaitFor | None = Field(
        WaitFor.running,
        alias="waitFor",
        description="Readiness condition before steps execute: 'running' waits for container to run; 'healthy' waits for Docker healthcheck to report healthy.",
    )
    log_pattern: str | None = Field(
        None,
        alias="logPattern",
        description="Optional regex; if set, waits for this pattern to appear in container logs before steps run.",
    )
    restart_policy: str | None = Field(
        None,
        alias="restartPolicy",
        description="Docker restart policy for the container: 'no', 'always', or 'unless-stopped'.",
    )
    keep_container: bool | None = Field(
        False,
        alias="keepContainer",
        description="Keep the container running after the step completes. Useful for debugging or when running services that need to persist between steps.",
    )


class SshConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    user: str = Field(..., description="SSH username for authentication.")
    host: str = Field(..., description="Hostname or IP address of the SSH server.")
    port: str | None = Field("22", description="SSH port number. Defaults to 22.")
    key: str | None = Field(
        None,
        description="Path to the SSH private key file. If not specified, defaults are tried: ~/.ssh/id_rsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519, ~/.ssh/id_dsa.",
    )
    password: str | None = Field(
        None,
        description="SSH password for authentication (not recommended; prefer key-based auth).",
    )
    strict_host_key: bool | None = Field(
        True,
        alias="strictHostKey",
        description="Enable strict host key checking. When true (default), verifies the server's host key against known_hosts. Set to false only for testing.",
    )
    known_host_file: str | None = Field(
        "~/.ssh/known_hosts",
        alias="knownHostFile",
        description="Path to the known_hosts file for host key verification. Defaults to ~/.ssh/known_hosts.",
    )


class Step(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Unique identifier for the step within this DAG. If omitted, Dagu will automatically generate a name.",
    )
    id: str | None = Field(
        None,
        description="Optional short identifier for the step. Can be used in variable references like ${id.stdout} to access step properties. Must be unique within the DAG if specified.",
    )
    description: str | None = Field(
        None,
        description="Brief description of what this step does. Helps document the step's purpose.",
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory for the step. Inherits from DAG's workingDir if not specified. Overrides DAG-level workingDir for this step.",
    )
    executor: str | Executor | None = Field(
        None,
        description="Specialized executor configuration for running the step (e.g., docker for containerized execution, http for API calls, mail for sending emails).",
    )
    command: str | list[str] | None = Field(
        None,
        description="Command to execute. Can be a shell command, script interpreter, or executable. If omitted when script is provided, uses system default shell.",
    )
    shell: str | None = Field(
        None,
        description="Specific shell to use for executing the command. Defaults to $SHELL or sh if not specified.",
    )
    shell_packages: list[str] | None = Field(
        None,
        alias="shellPackages",
        description="List of packages to install before executing the step. Useful for ensuring dependencies are available. It's only available when the shell is nix-shell.",
    )
    script: str | None = Field(
        None,
        description="Multi-line script content that will be executed. Gets piped into the command if specified, otherwise uses default shell.",
    )
    stdout: str | None = Field(
        None,
        description="File path where the step's standard output (stdout) will be written.",
    )
    stderr: str | None = Field(
        None,
        description="File path where the step's standard error (stderr) will be written.",
    )
    output: str | None = Field(
        None,
        description="Variable name to capture the command's stdout. This output can be referenced in subsequent steps.",
    )
    depends: str | list[str] | None = None
    continue_on: ContinueOn | None = Field(
        None,
        alias="continueOn",
        description="Conditions under which the DAG should continue executing even if this step fails or is skipped.",
    )
    retry_policy: RetryPolicy | None = Field(
        None,
        alias="retryPolicy",
        description="Configuration for automatically retrying failed steps.",
    )
    repeat_policy: RepeatPolicy | None = Field(
        None,
        alias="repeatPolicy",
        description="Configuration for repeatedly executing this step at fixed intervals or until a condition is met. Supports string matching, command substitution, and exit code checks.",
    )
    mail_on_error: bool | None = Field(
        None,
        alias="mailOnError",
        description="Send an email notification if this specific step fails.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be met before this step can run. Supports command exit codes, environment variables, and regex matching.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    signal_on_stop: str | None = Field(
        None,
        alias="signalOnStop",
        description="Signal to send when stopping this step (e.g., SIGINT). If empty, uses same signal as parent process.",
    )
    run: str | None = Field(None, description="Name of a DAG to run.")
    params: str | list[dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Default parameters that can be overridden when triggering the DAG. Can be positional (accessed as $1, $2) or named (accessed as ${KEY}).",
    )
    parallel: str | list[str | float | dict[str, Any]] | Parallel | None = Field(
        None,
        description="Configuration for parallel execution of child DAGs. Only applicable when 'run' is specified. Allows processing multiple items concurrently using the same workflow definition.",
    )
    worker_selector: dict[str, str] | None = Field(
        None,
        alias="workerSelector",
        description='Key-value pairs specifying worker label requirements for executing this step. The step will only run on workers that have all specified labels with matching values. For example: {"gpu": "true", "memory": "64G"} requires a worker with both gpu=true and memory=64G labels.',
    )
    env: list[dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Environment variables specific to this step. These override DAG-level environment variables with the same name. Can use shell expansions, references to other environment variables, or command substitutions.",
    )


class HandlerOn(HomelabBaseModel):
    failure: Step | None = None
    success: Step | None = None
    cancel: Step | None = None
    exit: Step | None = None


class StepItem(HomelabRootModel[Step | str | list[Step | str]]):
    root: Step | str | list[Step | str]


class Model(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Name of the DAG. If omitted, defaults to the YAML filename without extension.",
    )
    description: str | None = Field(
        None,
        description="A brief description explaining what this DAG does. This helps document the DAG's purpose.",
    )
    group: str | None = Field(
        None,
        description="An organizational label used to group related DAGs together. Useful for categorizing DAGs in the UI, e.g., 'DailyJobs', 'Analytics'.",
    )
    dotenv: str | list[str] | None = Field(
        None,
        description='Specifies .env files to load environment variables from. Defaults to [".env"] if not specified. Set to empty array [] to disable .env loading. Files are loaded relative to the DAG\'s workingDir.',
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory for the DAG. All relative paths (including dotenv files) are resolved relative to this directory. Defaults to the directory containing the DAG file.",
    )
    schedule: str | list[str] | Schedule | None = Field(
        None,
        description="Schedule configuration for the DAG. Can be a simple cron expression, multiple cron expressions, or an object with start/stop/restart schedules. If omitted, the DAG will only run manually.",
    )
    skip_if_successful: bool | None = Field(
        None,
        alias="skipIfSuccessful",
        description="When true, Dagu checks if this DAG has already succeeded since the last scheduled time. If it has, Dagu will skip the current scheduled run. This is useful for resource-intensive tasks or data processing jobs that shouldn't run twice. Note: Manual triggers always run regardless of this setting.",
    )
    tags: str | list[str] | None = Field(
        None,
        description="Tags for categorizing and searching DAGs. Useful for filtering and organizing DAGs.",
    )
    type: Type | None = Field(
        Type.chain,
        description="Execution type for steps. 'chain' (default) executes steps sequentially in the order they are defined, with each step automatically depending on the previous one. 'graph' uses dependency-based execution where steps run based on their 'depends' field. 'agent' is reserved for future agent-based execution.",
    )
    env: list[dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Environment variables available to all steps in the DAG. Can use shell expansions, references to other environment variables, or command substitutions. Note: These won't be stored in execution history data for security.",
    )
    log_dir: str | None = Field(
        None,
        alias="logDir",
        description="Base directory for storing logs. Defaults to ${HOME}/.local/share/logs if not specified.",
    )
    handler_on: HandlerOn | None = Field(
        None,
        alias="handlerOn",
        description="Lifecycle event hooks that define commands to execute when the DAG succeeds, fails, is cancelled, or exits. Useful for cleanup, notifications, or triggering dependent DAGs.",
    )
    smtp: Smtp | None = Field(
        None, description="SMTP server configuration for sending email notifications."
    )
    mail_on: MailOn | None = Field(
        None,
        alias="mailOn",
        description="Configuration for sending email notifications on DAG success or failure.",
    )
    error_mail: MailConfig | None = Field(
        None,
        alias="errorMail",
        description="Email configuration specifically for error notifications.",
    )
    info_mail: MailConfig | None = Field(
        None,
        alias="infoMail",
        description="Email configuration for informational notifications.",
    )
    timeout_sec: int | None = Field(
        None,
        alias="timeoutSec",
        description="Maximum number of seconds allowed for the entire DAG to finish. If exceeded, the DAG is considered timed out.",
    )
    delay_sec: int | None = Field(
        None,
        alias="delaySec",
        description="Delay in seconds before starting the first node. Useful for staggering workloads.",
    )
    restart_wait_sec: int | None = Field(
        None,
        alias="restartWaitSec",
        description="Number of seconds to wait before restarting a failed or stopped DAG. Typically used with a process supervisor.",
    )
    hist_retention_days: int | None = Field(
        None,
        alias="histRetentionDays",
        description="Number of days to retain execution history. After this period, older run logs/history can be purged.",
    )
    max_active_runs: int | None = Field(
        1,
        alias="maxActiveRuns",
        description="Maximum number of concurrent DAG runs allowed. Useful for limiting resource usage and preventing overload. If exceeded, new runs will be queued until existing ones complete. Defaults to 1. Set to -1 to disable queueing for this DAG.",
    )
    queue: str | None = Field(
        None,
        description="Name of the queue to assign this DAG to. If not specified, defaults to the DAG name. Used with global queue configuration to control concurrent execution across multiple DAGs.",
    )
    max_active_steps: int | None = Field(
        None,
        alias="maxActiveSteps",
        description="Maximum number of concurrent steps that can be active at once. Useful for limiting resource usage.",
    )
    max_clean_up_time_sec: int | None = Field(
        None,
        alias="maxCleanUpTimeSec",
        description="Maximum time in seconds to spend cleaning up (stopping steps, finalizing logs) before forcing shutdown. If exceeded, processes will be killed.",
    )
    max_output_size: int | None = Field(
        1048576,
        alias="maxOutputSize",
        description="Maximum size in bytes for the output of each step. If a step's output exceeds this limit, it will fail with an error. Defaults to 1MB (1048576 bytes). This limit also applies to pattern matching in preconditions and continueOn conditions.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be satisfied before the DAG can run. Can use shell expansions or command substitutions to validate external states.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    params: str | list[dict[str, Any]] | dict[str, Any] | Params | None = Field(
        None,
        description="Default parameters that can be overridden when triggering the DAG. Supports positional parameters (accessed as $1, $2), named parameters (accessed as ${KEY}), or JSON Schema validation mode with reserved keywords 'schema' and 'values'.",
    )
    container: Container | None = Field(
        None,
        description="Default container configuration for all steps in the DAG. Steps can override this configuration with their own container settings.",
    )
    ssh: SshConfig | None = Field(
        None,
        description="Default SSH configuration for all steps in the DAG. Steps can override this configuration with their own SSH settings. Note: SSH and container configurations are mutually exclusive at the DAG level.",
    )
    steps: list[StepItem] | dict[str, Step] | None = None
    otel: OtelConfig | None = Field(
        None,
        description="OpenTelemetry tracing configuration for distributed tracing of DAG execution.",
    )
    run_config: RunConfig | None = Field(
        None,
        alias="runConfig",
        description="Configuration for controlling user interactions when starting DAG runs. Allows restricting parameter editing and custom run ID input.",
    )
