# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/dagu-org/dagu/main/schemas/dag.schema.json
#   timestamp: 2025-12-29T07:05:05+00:00

from enum import StrEnum
from typing import Any

from homelab_pydantic import HomelabBaseModel, HomelabRootModel
from pydantic import ConfigDict, Field


class ModelSchedule(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    start: str | list[str] | None = None
    stop: str | list[str] | None = None
    restart: str | list[str] | None = None


class ModelType(StrEnum):
    GRAPH = "graph"
    CHAIN = "chain"
    AGENT = "agent"


class ModelEnv(HomelabRootModel[str]):
    root: str = Field(
        ...,
        description="Key=Value format: 'KEY=value'",
        pattern="^[A-Za-z_][A-Za-z0-9_]*=.*$",
    )


class ModelLogOutput(StrEnum):
    SEPARATE = "separate"
    MERGED = "merged"


class ModelSmtp(HomelabBaseModel):
    host: str | None = Field(None, description="SMTP server hostname")
    port: str | int | None = Field(None, description="SMTP server port")
    username: str | None = Field(None, description="SMTP authentication username")
    password: str | None = Field(None, description="SMTP authentication password")


class ModelMailOn(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Send email notification when DAG fails"
    )
    success: bool | None = Field(
        None, description="Send email notification when DAG succeeds"
    )


class ModelParams(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    schema_: str = Field(
        ...,
        alias="schema",
        description="Path to JSON Schema file (local file or remote URL) for parameter validation",
    )
    values: dict[str, Any] | None = Field(
        None, description="Default parameter values to be validated against the schema"
    )


class ModelRegistryAuths(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    username: str | None = Field(
        None,
        description="Registry username. Supports environment variable expansion (e.g., ${DOCKER_USERNAME}).",
    )
    password: str | None = Field(
        None,
        description="Registry password or access token. Supports environment variable expansion (e.g., ${DOCKER_PASSWORD}).",
    )
    auth: str | None = Field(
        None,
        description="Pre-encoded authentication string. Should be base64(username:password) or a JSON string with credentials. Use this instead of username/password for pre-encoded credentials.",
    )


class ModelRunConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    disable_param_edit: bool | None = Field(
        False,
        alias="disableParamEdit",
        description="When true, prevents users from modifying DAG parameters when starting the DAG. Defaults to false (users can edit parameters).",
    )
    disable_run_id_edit: bool | None = Field(
        False,
        alias="disableRunIdEdit",
        description="When true, prevents users from entering custom run IDs when starting the DAG. Defaults to false (users can enter custom run IDs).",
    )


class SecretRef(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(
        ..., description="Environment variable name that will receive the secret value."
    )
    provider: str = Field(
        ...,
        description="Secret provider identifier (e.g., env, file, custom providers).",
    )
    key: str = Field(
        ...,
        description="Provider-specific key or identifier used to look up the secret.",
    )
    options: dict[str, str] | None = Field(
        None,
        description="Provider-specific configuration options. Values must be strings to support serialization.",
    )


class StepExecutorType(StrEnum):
    COMMAND = "command"
    SHELL = "shell"
    DOCKER = "docker"
    CONTAINER = "container"
    HTTP = "http"
    MAIL = "mail"
    SSH = "ssh"
    JQ = "jq"
    GHA = "gha"
    GITHUB_ACTION = "github_action"
    github_action_1 = "github-action"
    DAG = "dag"
    SUBWORKFLOW = "subworkflow"
    PARALLEL = "parallel"
    ARCHIVE = "archive"


class StepExecutor(HomelabBaseModel):
    type: StepExecutorType = Field(
        ...,
        description="Type of executor to use for this step. 'command' is the default shell command executor. 'dag' is for sub-DAG execution. 'parallel' is for parallel step execution.",
    )
    config: dict[str, Any] | None = Field(
        None, description="Executor-specific configuration options."
    )


class StepLogOutput(StrEnum):
    SEPARATE = "separate"
    MERGED = "merged"


class StepOutput(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str = Field(
        ..., description="Variable name to capture the command's stdout (required)."
    )
    key: str | None = Field(
        None,
        description="Custom key for this output in outputs.json. If not specified, the variable name is converted to camelCase.",
    )
    omit: bool | None = Field(
        False, description="When true, excludes this output from outputs.json."
    )


class StepContinueOn(StrEnum):
    SKIPPED = "skipped"
    FAILED = "failed"


class StepContinueOn1(HomelabBaseModel):
    failure: bool | None = Field(
        None, description="Continue dag-run even if this step fails"
    )
    skipped: bool | None = Field(
        None,
        description="Continue dag-run even if this step is skipped due to preconditions",
    )
    exit_code: int | str | list[int] | None = Field(None, alias="exitCode")
    output: str | list[str] | None = None
    mark_success: bool | None = Field(
        None,
        alias="markSuccess",
        description="Mark the step as successful even if it technically failed but met continue conditions",
    )


class StepRetryPolicy(HomelabBaseModel):
    limit: int | str | None = Field(
        None, description="Maximum number of retry attempts"
    )
    interval_sec: int | str | None = Field(
        None, alias="intervalSec", description="Seconds to wait between retry attempts"
    )
    backoff: bool | float | None = Field(
        None, description="Exponential backoff multiplier for retry delays"
    )
    max_interval_sec: int | None = Field(
        None,
        alias="maxIntervalSec",
        description="Maximum interval in seconds (caps exponential growth)",
    )
    exit_code: list[int] | None = Field(
        None,
        alias="exitCode",
        description="List of exit codes that should trigger a retry. If not specified, all non-zero exit codes will trigger a retry.",
    )


class StepRepeatPolicyRepeat(StrEnum):
    WHILE_ = "while"
    UNTIL = "until"


class StepRepeatPolicy(HomelabBaseModel):
    repeat: bool | StepRepeatPolicyRepeat | None = Field(
        None,
        description="Determines if and how the step should be repeated. Can be a boolean or a string ('while' or 'until').",
    )
    interval_sec: int | None = Field(
        None, alias="intervalSec", description="Interval in seconds between repetitions"
    )
    limit: int | None = Field(
        None,
        description="Maximum number of times this step will be executed. Once reached, the step stops repeating regardless of other conditions.",
        ge=1,
    )
    backoff: bool | float | None = Field(
        None, description="Exponential backoff multiplier for repeat delays"
    )
    max_interval_sec: int | None = Field(
        None,
        alias="maxIntervalSec",
        description="Maximum interval in seconds (caps exponential growth)",
    )
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate for repeat-until. Can include shell commands, environment variables, or command substitutions.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix.",
    )
    exit_code: int | list[int] | None = Field(
        None,
        alias="exitCode",
        description="Exit code or list of exit codes that will stop repetition. If not specified, all non-zero exit codes will trigger repetition.",
    )


class StepParallel(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    items: str | list[str | float | dict[str, Any]]
    max_concurrent: int | None = Field(
        10,
        alias="maxConcurrent",
        description="Maximum number of concurrent executions (default: 10, maximum: 1000)",
        ge=1,
        le=1000,
    )


class StepEnv(HomelabRootModel[str]):
    root: str = Field(
        ...,
        description="Key=Value format: 'KEY=value'",
        pattern="^[A-Za-z_][A-Za-z0-9_]*=.*$",
    )


class Condition(HomelabBaseModel):
    condition: str | None = Field(
        None,
        description="Command or expression to evaluate. Can include shell commands, environment variables, or command substitutions with backticks.",
    )
    command: str | None = Field(
        None,
        description="Deprecated alias for condition. Still accepted for backward compatibility.",
    )
    expected: str | None = Field(
        None,
        description="Expected value or pattern to match against the condition result. Supports regex patterns with 're:' prefix (e.g., 're:0[1-9]' for matching numbers 01-09).",
    )
    negate: bool | None = Field(
        None,
        description="If true, inverts the condition result. The DAG/step will run when the condition does NOT match the expected value.",
    )


class MailConfig(HomelabBaseModel):
    from_: str | None = Field(
        None,
        alias="from",
        description="Email address to use as the sender address for notifications.",
    )
    to: str | list[str] | None = Field(
        None,
        description="Email address(es) to receive notifications. Can be a single string or an array of strings.",
    )
    prefix: str | None = Field(
        None,
        description="Text to prepend to the email subject line. Useful for filtering or categorizing notification emails.",
    )
    attach_logs: bool | None = Field(
        None,
        alias="attachLogs",
        description="When true, relevant log files will be attached to the notification email.",
    )


class OtelConfigResource(HomelabBaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    service_name: str | None = Field(
        None,
        alias="service.name",
        description="Service name for the traces. Defaults to 'dagu' if not specified. Can use variables like ${DAG_NAME}.",
    )
    service_version: str | None = Field(
        None,
        alias="service.version",
        description="Version of the service producing the traces.",
    )
    deployment_environment: str | None = Field(
        None,
        alias="deployment.environment",
        description="Deployment environment (e.g., production, staging, development).",
    )


class OtelConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    enabled: bool | None = Field(
        None,
        description="Enable or disable OpenTelemetry tracing for this DAG. When false, no traces will be exported.",
    )
    endpoint: str | None = Field(
        None,
        description="OTLP endpoint URL for exporting traces. Supports both gRPC (e.g., http://localhost:4317) and HTTP (e.g., http://localhost:4318/v1/traces) protocols.",
    )
    headers: dict[str, Any] | None = Field(
        None,
        description="Custom headers to include with OTLP export requests. Useful for authentication (e.g., Authorization: Bearer token).",
    )
    insecure: bool | None = Field(
        False,
        description="Skip TLS certificate verification when connecting to the OTLP endpoint. Only use in development environments.",
    )
    timeout: str | None = Field(
        None,
        description="Timeout for exporting traces to the OTLP endpoint. Accepts duration strings like '30s', '1m', '5m'.",
    )
    resource: OtelConfigResource | None = Field(
        None,
        description="Resource attributes to attach to all spans. Common attributes include service.name, service.version, and deployment.environment.",
    )


class ContainerPullPolicy(StrEnum):
    ALWAYS = "always"
    NEVER = "never"
    MISSING = "missing"


class ContainerEnv(HomelabRootModel[str]):
    root: str = Field(..., pattern="^[A-Za-z_][A-Za-z0-9_]*=.*$")


class ContainerStartup(StrEnum):
    KEEPALIVE = "keepalive"
    ENTRYPOINT = "entrypoint"
    COMMAND = "command"


class ContainerWaitFor(StrEnum):
    RUNNING = "running"
    HEALTHY = "healthy"


class Container(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Custom container name. If empty, Docker generates a random name. Must be unique - if a container with this name already exists (running or stopped), the DAG will fail.",
    )
    image: str = Field(
        ...,
        description="Container image to use (e.g., 'python:3.11', 'node:20'). Required when using container configuration.",
    )
    pull_policy: bool | ContainerPullPolicy | None = Field(
        ContainerPullPolicy.MISSING,
        alias="pullPolicy",
        description="Image pull policy. Accepts boolean (true='always', false='never') or string ('always', 'never', 'missing'). Default is 'missing'.",
    )
    env: list[dict[str, Any] | ContainerEnv] | dict[str, Any] | None = Field(
        None,
        description="Environment variables to set in the container. Supports maps or arrays combining maps and KEY=value strings. Values can include variable expansion (e.g., 'API_KEY=${API_KEY}').",
    )
    volumes: list[str] | None = Field(
        None,
        description="Volume mounts for the container. Format: 'host_path:container_path[:mode]' where mode is 'ro' for read-only or 'rw' (default) for read-write. Relative paths (starting with './' or '.') are resolved relative to the DAG's workingDir.",
    )
    user: str | None = Field(
        None,
        description="User (and optionally group) to run the container as. Format: 'user' or 'user:group' (e.g., '1000' or '1000:1000').",
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory inside the container. Commands will be executed from this directory.",
    )
    work_dir: str | None = Field(
        None,
        alias="workDir",
        description="Deprecated alias for workingDir. Still accepted for backward compatibility.",
    )
    platform: str | None = Field(
        None,
        description="Platform for the container (e.g., 'linux/amd64', 'linux/arm64'). Useful for ensuring compatibility on different architectures.",
    )
    ports: list[str] | None = Field(
        None,
        description="Ports to expose from the container. Format: 'host_port:container_port' or just 'container_port'.",
    )
    network: str | None = Field(
        None,
        description="Network mode for the container (e.g., 'host', 'bridge', 'none', or a custom network name).",
    )
    startup: ContainerStartup | None = Field(
        ContainerStartup.KEEPALIVE,
        description="Startup mode for the DAG-level container: 'keepalive' uses an internal keepalive/sleep, 'entrypoint' honors the image's ENTRYPOINT/CMD, 'command' runs the provided command array.",
    )
    command: list[str] | None = Field(
        None,
        description="Command to execute when startup is 'command'. Must be a non-empty array.",
    )
    wait_for: ContainerWaitFor | None = Field(
        ContainerWaitFor.RUNNING,
        alias="waitFor",
        description="Readiness condition before steps execute: 'running' waits for container to run; 'healthy' waits for Docker healthcheck to report healthy.",
    )
    log_pattern: str | None = Field(
        None,
        alias="logPattern",
        description="Optional regex; if set, waits for this pattern to appear in container logs before steps run.",
    )
    restart_policy: str | None = Field(
        None,
        alias="restartPolicy",
        description="Docker restart policy for the container: 'no', 'always', or 'unless-stopped'.",
    )
    keep_container: bool | None = Field(
        False,
        alias="keepContainer",
        description="Keep the container running after the step completes. Useful for debugging or when running services that need to persist between steps.",
    )


class SshConfig(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    user: str = Field(..., description="SSH username for authentication.")
    host: str = Field(..., description="Hostname or IP address of the SSH server.")
    port: str | int | None = Field("22", description="SSH port number. Defaults to 22.")
    key: str | None = Field(
        None,
        description="Path to the SSH private key file. If not specified, defaults are tried: ~/.ssh/id_rsa, ~/.ssh/id_ecdsa, ~/.ssh/id_ed25519, ~/.ssh/id_dsa.",
    )
    password: str | None = Field(
        None,
        description="SSH password for authentication (not recommended; prefer key-based auth).",
    )
    strict_host_key: bool | None = Field(
        True,
        alias="strictHostKey",
        description="Enable strict host key checking. When true (default), verifies the server's host key against known_hosts. Set to false only for testing.",
    )
    known_host_file: str | None = Field(
        "~/.ssh/known_hosts",
        alias="knownHostFile",
        description="Path to the known_hosts file for host key verification. Defaults to ~/.ssh/known_hosts.",
    )


class Step(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Unique identifier for the step within this DAG. If omitted, Dagu will automatically generate a name.",
    )
    dir: str | None = Field(
        None,
        description="Deprecated alias for workingDir. Still accepted for backward compatibility.",
    )
    id: str | None = Field(
        None,
        description="Optional short identifier for the step. Can be used in variable references like ${id.stdout} to access step properties. Must be unique within the DAG if specified.",
    )
    description: str | None = Field(
        None,
        description="Brief description of what this step does. Helps document the step's purpose.",
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory for the step. Inherits from DAG's workingDir if not specified. Overrides DAG-level workingDir for this step.",
    )
    executor: str | StepExecutor | None = Field(
        None,
        description="Specialized executor configuration for running the step (e.g., docker for containerized execution, http for API calls, mail for sending emails, gha for running GitHub Actions locally).",
    )
    command: str | list[str | float | bool] | None = Field(
        None,
        description="Command(s) to execute. Can be a single shell command string, or an array of commands to run sequentially (stops on first failure).",
    )
    shell: str | list[str] | None = Field(
        None,
        description="Shell to use for executing the command. Can be specified as a string with arguments (e.g., '/bin/bash -e') which will be automatically tokenized, or as an array for explicit argument separation. Overrides DAG-level shell if specified. Defaults to DAG-level shell, or $SHELL/sh if not specified.",
    )
    shell_packages: list[str] | None = Field(
        None,
        alias="shellPackages",
        description="List of packages to install before executing the step. Useful for ensuring dependencies are available. It's only available when the shell is nix-shell.",
    )
    script: str | None = Field(
        None,
        description="Multi-line script content that will be executed. Gets piped into the command if specified, otherwise uses default shell.",
    )
    stdout: str | None = Field(
        None,
        description="File path where the step's standard output (stdout) will be written.",
    )
    stderr: str | None = Field(
        None,
        description="File path where the step's standard error (stderr) will be written.",
    )
    log_output: StepLogOutput | None = Field(
        None,
        alias="logOutput",
        description="Override DAG-level log output mode. 'separate' writes stdout to .out and stderr to .err files. 'merged' writes both to a single .log file.",
    )
    output: str | StepOutput | None = Field(
        None,
        description="Variable name to capture the command's stdout. Can be a string or an object with name, key, and omit fields. This output can be referenced in subsequent steps.",
    )
    depends: str | list[str] | None = None
    continue_on: StepContinueOn | StepContinueOn1 | None = Field(
        None,
        alias="continueOn",
        description="Conditions under which the DAG should continue executing even if this step fails or is skipped. Can be a string ('skipped' or 'failed') or an object with detailed configuration.",
    )
    retry_policy: StepRetryPolicy | None = Field(
        None,
        alias="retryPolicy",
        description="Configuration for automatically retrying failed steps.",
    )
    repeat_policy: StepRepeatPolicy | None = Field(
        None,
        alias="repeatPolicy",
        description="Configuration for repeatedly executing this step at fixed intervals or until a condition is met. Supports string matching, command substitution, and exit code checks.",
    )
    mail_on_error: bool | None = Field(
        None,
        alias="mailOnError",
        description="Send an email notification if this specific step fails.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be met before this step can run. Supports command exit codes, environment variables, and regex matching.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    signal_on_stop: str | None = Field(
        None,
        alias="signalOnStop",
        description="Signal to send when stopping this step (e.g., SIGINT). If empty, uses same signal as parent process.",
    )
    timeout_sec: int | None = Field(
        None,
        alias="timeoutSec",
        description="Maximum execution time for the step in seconds. If set, this timeout takes precedence over the DAG-level timeout for this step.",
        ge=0,
    )
    call: str | None = Field(
        None, description="Name of a DAG to execute as a sub dag-run."
    )
    run: str | None = Field(
        None,
        description="Legacy field for DAG execution. Deprecated: use call instead.",
    )
    params: str | list[str | dict[str, Any]] | dict[str, Any] | None = Field(
        None,
        description="Parameters for the step. Supports three formats: 1) String format: space-separated positional parameters (e.g., 'arg1 arg2') accessible as $1, $2. 2) Array format: named parameters as key-value objects preserving rich types (numbers, booleans, nested objects). 3) Object format: named parameters as simple key-value pairs. For sub-DAG execution (when 'call' or 'run' is specified), these are passed to the sub DAG and accessible as ${KEY}. For 'gha' executor, these are passed as action inputs (the 'with:' section in GitHub Actions syntax). Rich types are preserved when passing to executors that support them.",
    )
    parallel: str | list[str | float | dict[str, Any]] | StepParallel | None = Field(
        None,
        description="Configuration for parallel execution of sub DAGs. Only applicable when 'run' is specified. Allows processing multiple items concurrently using the same workflow definition.",
    )
    worker_selector: dict[str, str] | None = Field(
        None,
        alias="workerSelector",
        description='Key-value pairs specifying worker label requirements for executing this step. The step will only run on workers that have all specified labels with matching values. For example: {"gpu": "true", "memory": "64G"} requires a worker with both gpu=true and memory=64G labels.',
    )
    env: list[dict[str, Any] | StepEnv] | dict[str, Any] | None = Field(
        None,
        description="Environment variables specific to this step. These override DAG-level environment variables with the same name. Supports three formats: 1) Map format: env: {KEY: value}, 2) Array of maps: env: [{KEY: value}], 3) Array of Key=Value strings: env: ['KEY=value'] (Docker/docker-compose compatible). Can use shell expansions (${VAR}), references to other environment variables, or command substitutions (`cmd`). When used with 'container' field, these are merged with container.env.",
    )
    container: Container | None = Field(
        None,
        description="Container configuration for this step. When specified, the step runs in its own container instead of the DAG-level container. Uses the same configuration format as the DAG-level container field. Note: Cannot be used together with 'executor'.",
    )


class ModelHandlerOn(HomelabBaseModel):
    init: Step | None = Field(
        None,
        description="Step to execute before any workflow steps run (after preconditions pass). If this fails, the DAG fails and no steps execute.",
    )
    failure: Step | None = None
    success: Step | None = None
    abort: Step | None = Field(
        None, description="Step to execute when the DAG is aborted."
    )
    exit: Step | None = None


class StepItem(HomelabRootModel[Step | str | list[Step | str]]):
    root: Step | str | list[Step | str]


class Model(HomelabBaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    name: str | None = Field(
        None,
        description="Name of the DAG. If omitted, defaults to the YAML filename without extension.",
    )
    description: str | None = Field(
        None,
        description="A brief description explaining what this DAG does. This helps document the DAG's purpose.",
    )
    group: str | None = Field(
        None,
        description="An organizational label used to group related DAGs together. Useful for categorizing DAGs in the UI, e.g., 'DailyJobs', 'Analytics'.",
    )
    dotenv: str | list[str] | None = Field(
        None,
        description='Specifies .env files to load environment variables from. Defaults to [".env"] if not specified. Set to empty array [] to disable .env loading. Files are loaded relative to the DAG\'s workingDir.',
    )
    working_dir: str | None = Field(
        None,
        alias="workingDir",
        description="Working directory for the DAG. All relative paths (including dotenv files) are resolved relative to this directory. Defaults to the directory containing the DAG file.",
    )
    schedule: str | list[str] | ModelSchedule | None = Field(
        None,
        description="Schedule configuration for the DAG. Can be a simple cron expression, multiple cron expressions, or an object with start/stop/restart schedules. If omitted, the DAG will only run manually.",
    )
    skip_if_successful: bool | None = Field(
        None,
        alias="skipIfSuccessful",
        description="When true, Dagu checks if this DAG has already succeeded since the last scheduled time. If it has, Dagu will skip the current scheduled run. This is useful for resource-intensive tasks or data processing jobs that shouldn't run twice. Note: Manual triggers always run regardless of this setting.",
    )
    tags: str | list[str] | None = Field(
        None,
        description="Tags for categorizing and searching DAGs. Useful for filtering and organizing DAGs.",
    )
    type: ModelType | None = Field(
        ModelType.CHAIN,
        description="Execution type for steps. 'chain' (default) executes steps sequentially in the order they are defined, with each step automatically depending on the previous one. 'graph' uses dependency-based execution where steps run based on their 'depends' field. 'agent' is reserved for future agent-based execution.",
    )
    env: list[dict[str, Any] | ModelEnv] | dict[str, Any] | None = Field(
        None,
        description="Environment variables available to all steps in the DAG. Supports three formats: 1) Map format: env: {KEY: value}, 2) Array of maps: env: [{KEY: value}], 3) Array of Key=Value strings: env: ['KEY=value'] (Docker/docker-compose compatible). Can use shell expansions (${VAR}), references to other environment variables, or command substitutions (`cmd`). Note: These won't be stored in execution history data for security.",
    )
    secrets: list[SecretRef] | None = Field(
        None,
        description="List of external secret references resolved at runtime and exposed as environment variables. Each entry declares the target environment variable name, provider, key, and optional provider-specific options.",
    )
    log_dir: str | None = Field(
        None,
        alias="logDir",
        description="Base directory for storing logs. Defaults to ${HOME}/.local/share/logs if not specified.",
    )
    log_output: ModelLogOutput | None = Field(
        ModelLogOutput.SEPARATE,
        alias="logOutput",
        description="Controls how stdout and stderr are logged. 'separate' writes stdout to .out and stderr to .err files. 'merged' writes both to a single .log file with interleaved output.",
    )
    handler_on: ModelHandlerOn | None = Field(
        None,
        alias="handlerOn",
        description="Lifecycle event hooks that define commands to execute at various points in the DAG lifecycle: init (before steps), success, failure, abort, and exit (always runs last).",
    )
    smtp: ModelSmtp | None = Field(
        None, description="SMTP server configuration for sending email notifications."
    )
    mail_on: ModelMailOn | None = Field(
        None,
        alias="mailOn",
        description="Configuration for sending email notifications on DAG success or failure.",
    )
    error_mail: MailConfig | None = Field(
        None,
        alias="errorMail",
        description="Email configuration specifically for error notifications.",
    )
    info_mail: MailConfig | None = Field(
        None,
        alias="infoMail",
        description="Email configuration for informational notifications.",
    )
    timeout_sec: int | None = Field(
        None,
        alias="timeoutSec",
        description="Maximum number of seconds allowed for the entire DAG to finish. If exceeded, the DAG is considered timed out.",
    )
    delay_sec: int | None = Field(
        None,
        alias="delaySec",
        description="Delay in seconds before starting the first node. Useful for staggering workloads.",
    )
    restart_wait_sec: int | None = Field(
        None,
        alias="restartWaitSec",
        description="Number of seconds to wait before restarting a failed or stopped DAG. Typically used with a process supervisor.",
    )
    hist_retention_days: int | None = Field(
        None,
        alias="histRetentionDays",
        description="Number of days to retain execution history. After this period, older run logs/history can be purged.",
    )
    max_active_runs: int | None = Field(
        1,
        alias="maxActiveRuns",
        description="Maximum number of concurrent DAG runs allowed. Useful for limiting resource usage and preventing overload. If exceeded, new runs will be queued until existing ones complete. Defaults to 1. Set to -1 to disable queueing for this DAG.",
    )
    queue: str | None = Field(
        None,
        description="Name of the queue to assign this DAG to. If not specified, defaults to the DAG name. Used with global queue configuration to control concurrent execution across multiple DAGs.",
    )
    max_active_steps: int | None = Field(
        None,
        alias="maxActiveSteps",
        description="Maximum number of concurrent steps that can be active at once. Useful for limiting resource usage.",
    )
    max_clean_up_time_sec: int | None = Field(
        None,
        alias="maxCleanUpTimeSec",
        description="Maximum time in seconds to spend cleaning up (stopping steps, finalizing logs) before forcing shutdown. If exceeded, processes will be killed.",
    )
    max_output_size: int | None = Field(
        1048576,
        alias="maxOutputSize",
        description="Maximum size in bytes for the output of each step. If a step's output exceeds this limit, it will fail with an error. Defaults to 1MB (1048576 bytes). This limit also applies to pattern matching in preconditions and continueOn conditions.",
    )
    precondition: str | list[Condition] | None = Field(
        None,
        description="Conditions that must be satisfied before the DAG can run. Can use shell expansions or command substitutions to validate external states.",
    )
    preconditions: str | list[Condition] | None = Field(
        None,
        description="Alternative name for precondition. Works exactly the same way.",
    )
    params: str | list[str | dict[str, Any]] | dict[str, Any] | ModelParams | None = (
        Field(
            None,
            description="Default parameters that can be overridden when triggering the DAG. Supports three formats: 1) String format: space-separated positional parameters (e.g., 'arg1 arg2') accessible as $1, $2. 2) Array/Object format: named parameters as key-value pairs accessible as ${KEY}, supporting rich types (numbers, booleans, nested objects). 3) Schema validation format: object with 'schema' (path to JSON Schema file) and optional 'values' (parameter values) for runtime validation and defaults.",
        )
    )
    container: Container | None = Field(
        None,
        description="Default container configuration for all steps in the DAG. Steps can override this configuration with their own container settings.",
    )
    registry_auths: str | dict[str, str | ModelRegistryAuths] | None = Field(
        None,
        alias="registryAuths",
        description="Authentication configuration for Docker container registries. Allows pulling images from private registries. Can be specified as a complete DOCKER_AUTH_CONFIG JSON string, or as a map of individual registry credentials. Authentication priority: 1) DAG-level registryAuths, 2) DOCKER_AUTH_CONFIG environment variable, 3) No authentication (public registries). Supports environment variable expansion with ${VAR} syntax.",
    )
    ssh: SshConfig | None = Field(
        None,
        description="Default SSH configuration for all steps in the DAG. Steps can override this configuration with their own SSH settings. Note: SSH and container configurations are mutually exclusive at the DAG level.",
    )
    steps: list[StepItem] | dict[str, Step] | None = None
    otel: OtelConfig | None = Field(
        None,
        description="OpenTelemetry tracing configuration for distributed tracing of DAG execution.",
    )
    run_config: ModelRunConfig | None = Field(
        None,
        alias="runConfig",
        description="Configuration for controlling user interactions when starting DAG runs. Allows restricting parameter editing and custom run ID input.",
    )
    worker_selector: dict[str, str] | None = Field(
        None,
        alias="workerSelector",
        description='Key-value pairs specifying worker label requirements for executing this DAG. The DAG will only run on workers that have all specified labels with matching values. For example: {"gpu": "true", "memory": "64G"} requires a worker with both gpu=true and memory=64G labels. This setting applies to the entire DAG; individual steps can override this with their own workerSelector.',
    )
    shell: str | list[str] | None = Field(
        None,
        description="Default shell to use for all steps in this DAG. Can be specified as a string with arguments (e.g., '/bin/bash -e') which will be automatically tokenized, or as an array for explicit argument separation. If not specified, the system default shell ($SHELL or /bin/sh) is used. Can be overridden at the step level.",
    )
